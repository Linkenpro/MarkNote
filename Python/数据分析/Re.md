# 正则表达式

Regular Expression，简称 Regex 或 RegExp，是一种用来匹配字符串中字符组合的模式。

1. **文本搜索与匹配**：快速判断一段文本中是否包含符合特定模式的子串。例如，检查一个字符串是否是一个有效的电子邮件地址格式。
2. **文本替换**：将文本中所有匹配特定模式的部分替换为新的内容。例如，将一篇文档中所有的日期格式从 `YYYY-MM-DD` 统一改为 `MM/DD/YYYY`。
3. **文本提取与分割**：从一大段文本中精确地提取出我们关心的部分，或者根据特定的分隔符将文本切分成数组。例如，从日志文件中提取所有的 IP 地址，或者用逗号分割一个 CSV 字符串。

> 匹配字符串中间的数字

```js
var str = "abc123def";
var patt1 = /[0-9]+/;
document.write(str.match(patt1));
```

> 查找相类似文件

```
data(\w)?\.dat
```

```
data.dat
data1.dat
data2.dat
datax.dat
dataN.dat
```

> 字符扩大了找到的文件的数量

```
data.*\.dat
```

```
data.dat
data1.dat
data2.dat
data12.dat
datax.dat
dataXYZ.dat
```

```
^[0-9]+abc$
```

- **^** 为匹配输入字符串的开始位置。
- **[0-9]+**匹配多个数字， **[0-9]** 匹配单个数字，**+** 匹配一个或者多个。
- **abc$**匹配字母 **abc** 并以 **abc** 结尾，**$** 为匹配输入字符串的结束位置。

> 字符、数字、下划线和连接字符 -

```
^[a-zA-Z0-9_-]{3,15}$
```

- `^` 表示匹配字符串的开头
- `[a-zA-Z0-9_-]` 表示字符集，包含**小写字母**、大写字母、**数字**、下划线和**连接字符** 
- `{3,15}` 表示前面的字符集最少出现 3 次，最多出现 15 次，从而限制了用户名的长度在 3 到 15 个字符之间。
- `$` 表示匹配字符串的结尾。

> 匹配以数字开头，并以 abc 结尾的字符串

```js
var str = "123abc";
var patt1 = /^[0-9]+abc$/;
document.write(str.match(patt1));
```

##### 字符匹配

| 匹配符 |                  说明                  |                       匹配类型                       |
| ------ | :------------------------------------: | :--------------------------------------------------: |
| a-z    |            小写字母，从a到z            |                       普通字符                       |
| A-Z    |            大写字母，从A到Z            |                       普通字符                       |
| \w     |         匹配字母、数字和下划线         |                        元字符                        |
| \d     |            匹配任意数字字符            |                                                      |
| [ ]    |        匹配括号内的任意一个字符        |           `[abc]` 匹配字符 "a"、"b" 或 "c"           |
| [^ ]   | 匹配除了括号内的字符以外的任意一个字符 | `[^abc]` 匹配除了字符 "a"、"b" 或 "c" 以外的任意字符 |

##### 量词

| 匹配符 |                匹配符                |      |
| ------ | :----------------------------------: | :--: |
| *      |       匹配前面的模式零次或多次       |      |
| +      |       匹配前面的模式一次或多次       |      |
| ？     |       匹配前面的模式零次或一次       |      |
| {n}    |       匹配前面的模式恰好 n 次        |      |
| {n,}   |       匹配前面的模式至少 n 次        |      |
| {n,m}  | 匹配前面的模式至少 n 次且不超过 m 次 |      |

##### 边界匹配

| 匹配符 | 说明             |      |
| ------ | ---------------- | ---- |
| ^      | 匹配字符串的开头 |      |
| $      | 匹配字符串的结尾 |      |
| \b     | 匹配单词边界     |      |
| \B     | 匹配非单词边界   |      |

##### 分组和捕获

| 匹配符 | 说明                     |      |
| ------ | ------------------------ | ---- |
| ( )    | 用于分组和捕获子表达式   |      |
| (?: )  | 用于分组但不捕获子表达式 |      |

##### 特殊字符

| 匹配符 | 说明                           |      |
| ------ | ------------------------------ | ---- |
| \      | 转义字符，用于匹配特殊字符本身 |      |
| .      | 匹配任意字符（除了换行符）     |      |
| \|     | 用于指定多个模式的选择         |      |

#### 语法

##### `+`

代表前面的字符必须至少出现一次（1次或多次）

> 贪婪匹配

```
runoo+b
```

匹配文本

```
runoob
runooob
runoooob
runoooooob 
```

##### `*`

> 贪婪匹配

代表前面的字符可以不出现，也可以出现一次或者多次

```
runo*b
```
匹配文本

```
runb
runooob
runoooob
runoooooob 
```

##### `？`

代表前面的字符最多只可以出现一次（0次或1次）

> 设置非贪婪匹配

```
colou?r
```

匹配文本

```
color
colour
```

##### 普通字符

###### [ABC]

匹配 **[ ]** 中的所有字符**ABC**

```
[aeiou]
匹配文本中a e i o u
```

匹配文本

```
google
runoob
taobao
```

###### [^ABC]

匹配除了 **[...]** 中字符的所有字符

```
[aeiou]
匹配文本中，除了a e i o u的字符
```

###### [A-Z]

表示一个区间，匹配所有大写字母

```
[A-Z]
```

表示所有小写字母

```
[a-z]
```

##### `.`

匹配除换行符（\n、\r）之外的任何单个字符

> 相等于 `[^\n\r]`

```
.
```

匹配文本

```
肉
ronb
[
]
+
```

###### `[\s\S]`

匹配所有

\s 是匹配所有空白符，包括换行

\S 非空白符，不包括换行

```
[\s\S]
```

匹配文本

```
r o n b
```

###### `\w`

匹配字母、数字、下划线

> 等价于 [A-Za-z0-9_]

```
\w
```

匹配文本

```
Google
runoob
```

###### `\d`

匹配任意一个阿拉伯数字（0 到 9）

> 等价于 **[0-9]**

```
\d+
```

匹配文本

```
123asd456fgh
```

##### 非打印字符

非打印字符也可以是正则表达式的组成部分

###### `\cx`

匹配由x指明的控制字符

```
\cM 匹配一个 Control-M 或回车符

x 的值必须为 A-Z 或 a-z 之一，否则
将 c 视为一个原义的 'c' 字符
```

###### `\f`

匹配一个换页符

```
\f
等价于
\x0c
\cL
```

匹配文本

```

```

###### `\n`

匹配一个换行符

```
\n
等价于
\x0a
\cJ
```

匹配文本

```

```

###### `\r`

匹配一个回车符

```
等价于
\x0d
\cM
```

匹配文本

```

```

###### `\s`

匹配任何空白字符，包括空格、制表符、换页符

```
\s
[ \f\n\r\t\v]
```

匹配文本

```

```

###### `\S`

匹配任何非空白字符

```
\S
[^ \f\n\r\t\v]
```

匹配文本

```

```

###### `\t`

匹配一个制表符

```
\t
\x09 
\cI
```

匹配文本

```
Tab
```

###### `\v`

匹配一个垂直制表符

```
\v
\x0b
\cK
```

匹配文本

```

```

##### 特殊字符

###### `\`

转义字符

```
匹配\
\\

匹配$
\$

匹配()
\( 和 \)

匹配*
\*

```

###### `$`

 匹配输入字符串的结尾位置

```

```

###### ()

标记一个子表达式的开始和结束位置

###### [

标记一个中括号表达式的开始

> 匹配一个正整数

```
/[1-9][0-9]*/

[1-9]设置第一个数字不是 0，[0-9]* 表示任意多个数字
```

> 设置 0~99 的两位数
>
> 只能匹配两位数字，可以匹配 0、00、01

```
/[0-9]{1,2}/
```

> 匹配 1~99 的正整数表达式

```
/[1-9][0-9]?/
或
/[1-9][0-9]{0,1}/
```



###### ^

- 匹配输入字符串的开始位置

  > 要匹配一行文本开始处的文本，请在正则表达式的开始使用 **^** 字符

- 在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合

###### {

标记限定符表达式的开始

```

```

###### |

指明两项之间的一个选择

##### 贪婪匹配

`*`和 `+` 限定符都是贪婪的,只有在它们的后面加上一个 `? `就可以实现非贪婪或最小匹配

> 匹配至第一个就停止

```
/<.*?>/

也可以使用以下正则表达式来匹配 h1 标签
/<\w+?>/
```

匹配文本

```
<h1>RUNOOB-菜鸟教程</h1>
```

##### 定位符

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

> 正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首

```
/^Chapter [1-9][0-9]{0,1}/
```

###### `\b`

> 匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面

```
\bCha
```

匹配文本

```
Change
Chapter
```

> 它位于字符串的结尾，它在单词的结尾处查找匹配项

```
ter\b
```

匹配文本

```
Computer
Reporter
Porter
```

> 表达式匹配 Chapter 中的字符串 apt,但不匹配 aptitude 中的字符串 apt

```
\Bapt
```

> 不匹配 Chapter 中的 Cha

```
\BCha
```

**()**

用圆括号 **()** 将所有选择项括起来，相邻的选择项之间用 **|** 分隔

`?:` 放在第一个选项前来消除这种副作用

###### `?=`

**语法：** `(?=...)`
**含义：** 匹配一个位置，**该位置之后的内容必须能匹配 `...`**，但不包含 `...` 本身

```
\w+(?=\d)
```

匹配文本

```
abc123
```

###### `?<=`

匹配一个位置，该位置之前的内容必须能匹配 ...，但不包含 ... 

```
(?<=\$)\d+
```

匹配文本

```
Price: $100
```

###### `?!`



###### `?<!`

> 语法： (?<!...)
>
> 匹配一个位置，该位置之前的内容不能匹配 ...

```
(?<!\$)\d+
```

匹配文本

```
Price: 100
```

输出所有匹配的数据

#### 正则表达式修饰符

用于改变正则表达式匹配行为的特殊指令

> 标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。
>
> 标记不写在正则表达式里，标记位于表达式之外，格式如下：

```
/pattern/flags
```

###### `/i`

忽略大小写

JavaScript、PHP、Python

```
/abc/i
```

匹配文本

```
abc
Abc
ABC
```

###### `/g`

- 全局匹配
- 查找所有匹配项
- 不是在第一个匹配后停止
- 支持语言：JavaScript、PHP

```
/ab/g
```

匹配文本

```
ababab
```

###### `/m`

多行模式

- 改变 `^` 和 `$` 的行为，使其匹配每行的开头和结尾，而不仅是整个字符串的开头和结尾
- 支持语言：JavaScript、PHP、Python、Perl等

```
/^abc/m
```

匹配文本

```
abc
```

###### `/s`

单行模式

- 使点号 `.` 匹配包括换行符在内的所有字符

- 支持语言：PHP、Perl、Python(作为`re.DOTALL`)、JavaScript(ES2018+)

```
/a.b/s
```

```
a\nb
```

###### `/u`

Unicode模式

- 启用完整的Unicode支持

- 正确处理UTF-16代理对和Unicode字符属性
- 支持语言：JavaScript、PHP等

> 可以匹配希腊字母

```
/\p{Script=Greek}/u
```

###### `/y`

粘性匹配

- 从目标字符串的当前位置开始匹配（使用`lastIndex`属性）
- 类似于`^`锚点，但针对的是匹配的起始位置
- 示例：在JavaScript中，`/a/y` 会从`lastIndex`开始匹配 "a"
- 支持语言：JavaScript

###### `/x`

扩展模式

- 忽略模式中的空白和注释，使正则表达式更易读
- 示例：在PHP中，`/a b c/x` 等同于 `/abc/`
- 支持语言：PHP、Perl、Python(作为`re.VERBOSE`)

##### 扩展说明

| 语言           | 特有修饰符 | 描述                                                |
| :------------- | :--------- | :-------------------------------------------------- |
| **PHP**        | `A`        | 锚定模式到字符串开头                                |
|                | `D`        | `$`仅匹配字符串结尾（不包括结尾换行）               |
|                | `U`        | 反转量词的贪婪性（使所有量词变为非贪婪）            |
| **Python**     | `re.A`     | 使`\w`,`\W`,`\b`,`\B`等仅匹配ASCII字符              |
|                | `re.L`     | 根据本地化设置确定`\w`,`\W`等的含义                 |
| **JS(ES2022)** | `d`        | 为匹配结果生成indices属性（包含匹配位置的起止索引） |

| 组合  | 效果                                                 |
| :---- | :--------------------------------------------------- |
| `gi`  | 全局匹配+忽略大小写（如查找所有格式的"email"单词）   |
| `ims` | 忽略大小写+多行模式+点号匹配换行符（常用于日志分析） |
| `gu`  | 全局匹配+Unicode支持（如查找所有Unicode表情符号）    |

内联修饰符表

| 语法       | 作用范围       | 示例                           |
| :--------- | :------------- | :----------------------------- |
| `(?i)`     | 启用忽略大小写 | `a(?i)bc` → 匹配 "aBc"、"aBC"  |
| `(?-i)`    | 禁用忽略大小写 | `a(?i)b(?-i)c` → 只匹配 "aBc"  |
| `(?i:...)` | 仅对括号内生效 | `a(?i:b)c` → 匹配 "aBc"、"abc" |

#### Python Re库









